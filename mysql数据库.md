[TOC]

# 数据库

范式。锁。 隔离。

索引

orm优缺点

数据库底层设计：10万用户10亿条记录 问你怎么存怎么高效查询 自己设计数据结构不许用第三方数据库

## 范式



# mysql逻辑架构

参考博客`https://blog.csdn.net/chenshun123/article/details/79677037`

1. 客户端，并非Mysql所独有，这一层负责连接处理，授权认证，安全等功能
2. 核心服务，包括查询解析。分析。优化。缓存。内置函数，所有的跨存储引擎的功能都在这一层实现：包括存储过程。触发器。视图等
3. 存储引擎，负责Mysql中的数据存储和提取，和Linux下的文件系统类似，每种存储引擎都有其优势和劣势，中间的服务层通过API与存储引擎通信，api接口屏蔽不同存储引擎间的差异

查询过程：

1. 客户端向mysql服务器发送一条查询请求
2. 服务器检查查询缓存，如果缓存命中，则立即返回存储在缓存中的结果，否则进入下一阶段
3. 服务器进行SQL解析。预处理。再由优化器生成对应的执行计划
4. Mysql根据执行计划，调用存储引擎的API来执行查询
5. 将结果返回给客户端，同时缓存查询结果

客户端服务端通信协议：

mysql客户端/服务端协议是半双工的，在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务端发送数据，这两个动作不能同时发生，一旦开始发送消息，另一段要接受完整个消息才能响应它，所以无法也无需将一个消息切成小块独立发送，也没办法进行流量控制

查询缓存：

在解析一个查询语句前，如果缓存是打开的，那么mysql会检查这个语句是否命中查询缓存中的数据，如果当前查询恰好命中查询缓存。在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行，Mysql将缓存存放在一个引用表，类似于HashMap的数据结构中，通过一个哈希值索引，这个哈希值通过查询本身，当前要查询的数据库，客户端协议版本等一些可能影响结果的信息计算得来的，所以两个查询在任何字符上的不同，都会导致缓存不会命中

查询中如果包含用户自定义函数，存储函数，用户变量，临时表，Mysql数据库中的系统表，则查询结果不会缓存

缓存系统会跟踪每一张表，如果发生数据或者结构变化，缓存数据会失效，所以任何的写操作都会导致对应表的缓存失效，缓存本身也会消耗资源，所以不是什么时候查询缓存都会提高系统性能

优化：

1. 多个小表代替一个大表，不要过度设计
2. 批量插入代替循环单条插入
3. 合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适

查询优化：

生成合法的语法树，由优化器将其转化为查询计划，一条查询可以有多种执行方式，最后都返回相应的结果，优化器的作用是找到其中最好的执行计划，Mysql使用基于成本的优化器，会预测一个查询使用的某种执行计划的成本，并选择成本最小的一个

查询执行引擎：

完成解析和优化以后，会生成对应的执行计划，查询执行引擎根据计划给出的指令逐步执行得到结果，整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API

返回结果给客户端：

返回查询结果，且如果查询缓存被打开，这个查询结果可以被缓存

# mysql引擎

常见存储引擎：

1. innoDB
2. MyISAM
3. Merge引擎，MyISAM引擎的一个变种
4. NDB集群引擎
5. CSV引擎，可以讲普通的CSV文件作为Mysql的表处理

### innoDB

Mysql默认的事务性引擎，被设计用来处理大量的短期事务，性能较高，自动崩溃恢复

索引结构B+树

根据主键引用被索引的行

### MyISAM

提供了大量的特性，包括全文索引，压缩，空间函数，但是不支持事务和行级锁，不支持崩溃后的安全恢复,

使用了前缀压缩技术，使得索引更小，通过数据的物理位置引用被索引的行

# 索引

索引式存储引擎用于快速找到记录的一种数据结构，这是索引的基本功能

索引优化是对查询优化的一种手段

索引是在存储引擎层实现的，而不是在服务器层实现的

作用：

1. 提高查询速度，但并不是任何石斛都可以提高查询速度，数据达到百万级才会有明显结果
2. 确保数据的唯一性
3. 加速表与表之间的连接
4. 使用分组和排序子句进行数据检索时，可以减少分组和排序的时间
5. 全文检索字段进行搜索优化

优点：

1. 索引大大减少了服务器需要扫描的数据量
2. 可以帮助服务器避免排序和临时表
3. 可以将随机IO变成顺序IO

 ## 索引类型

分类：

1. 主键索引，能够唯一标识一条记录，如id，只能有一个   
2. 唯一索引，可以有多个，避免同一个表中某数据列中的值重复，值必须唯一，但是允许有空值，如果是组合索引，则列值必须唯一
3. 常规索引，快速定位特定数据，应加在查询条件的字段，该索引不宜太多，会影响数据的插入，删除，和修改操作
4. 全文索引，只适用于MyISAM引擎的数据表，对类型也有要求
5. 联合索引，即组合索引

sql语句：

```mysql
create index indexName on table
```



### B树索引

实际技术上采用的是B+树，适用于全健值，健值范围或者键前缀查找，其中键前缀只适用于最左前缀的查找，组合索引列的顺序也很重要。

1. 全值匹配，即索引中的所有列进行匹配
2. 匹配最左前缀，只适用索引的第一列进行匹配
3. 匹配列前缀，匹配某一列的值的开头部分
4. 匹配范围值，匹配在某一范围内的值
5. 精确匹配某一列并范围匹配另一列

限制：

1. 如果不是按照索引的最左列开始查找，则无法适用索引
2. 不能跳过索引中的列
3. 如果查询中有某个列的范围查找，则其右边的所有列都无法使用索引优化查找

### 哈希索引

基于hash表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个hash码，haxi码比较小，不同键值的行计算出来的hash码也会不一样，哈希索引将所有的哈希码存储在索引当中，同时保存指向每个数据行的指针。Mysql中只有Memory引擎支持hash索引，也是该引擎的默认索引类型，该引擎支持非唯一hash的索引，如果出现哈希冲突，采用类似拉链法的冲突解决方式。

InnoDB自适应hash索引功能：当InnoDB中某些索引被使用的非常频繁的时候，会在内存中基于B树索引之上再创建一个hash索引，这是一个完全自动的。内部的行为，用户无法控制或者配置，但是可以关闭

# 并发控制

多个查询在同一时刻修改数据，会产生并发控制的原因，分为两个层面：

1. 服务器 层面
2. 存储引擎层面

基本的解决办法就是使用锁解决并发控制，在处理并发读或者写的时候，可以通过实现一个由两种类型的锁组成的锁系统来解决问题，这两种类型的锁被称为共享锁和排他锁，也叫读锁和写锁

读锁：共享的，互相不阻塞，多个客户在同一时刻可以同时读取同一个资源，而互不干扰

写锁：会阻塞其他的读锁和写锁，出于安全，保证在给定的时间里，只有一个用户能够执行写入，并防止其他用户读取正在写入的同一资源

锁粒度：读写锁可以保证数据的安全性，但是如果锁住了一张表，则极大的减小了并发性，所以为了提高共享资源并发性需要让锁对象更具有选择性，尽量锁定只需要修改的数据即可，而不是所有的资源

加锁也需要消耗资源，包括锁的各种操作，如获取，检查，解除，释放，都会增加系统开销，对于系统的性能可能会受到影响，所谓的锁策略，就是在锁的开销和数据的安全性之间寻求一个平衡，大多数的商业数据库系统都是施加行级锁

表锁：Mysql中的最基本的锁策略，也是开销最小的策略，一般场景下，都有良好的性能

行级锁：最大程度地支持并发处理，InnoDB和XtraDB实现了行级锁，行级锁只在存储引擎层面实现，服务器层面完全不了解存储引擎的锁实现。

### 乐观锁和悲观锁

并发控制过程中需要确保多个事务同时存取数据库中同一数据时，不破坏事务的隔离性和统一性以及数据库的统一性，与数据库中的锁机制不能混为一谈，悲观锁正是利用数据库本身提供的锁机制来实现的

悲观锁：假定并发冲突会发生，屏蔽一切可能违反数据完整性的操作

数据处理过程中，数据处于锁定状态，实现上往往依靠数据库提供的锁机制，也只有数据库提供的锁机制才能真正保证数据访问的排他性，主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本

对任意记录修改之前，给该记录加上排他锁，加锁失败，则是正在被修改，需要等待或者抛出异常，如果成功，就可以进行修改，事务完成就会解锁了

使用前必须关闭Mysql数据库的自动提交属性，Mysql使用了自动提交，也就是执行一个更新操作后，会立即将结果进行提交

InnoDB默认行级锁，行级锁是基于索引的，如果SQL语句没用到索引是不会使用行级锁，会使用表级锁把整张表锁住

先取锁再访问的保守策略，提供了安全保证，但是会增加额外开销，会增加死锁的机会，对于只读形事务不会产生冲突，没必要使用锁，这样做只会增加系统负载，降低并行性

乐观锁：假设并发冲突不会发生，只在提交操作时检查是否违反数据完整性

假设多用户并发的事务在处理是不会彼此影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据，在提交数据更新之前，每个事务先检查在该事务读取数据后其他事务是否有修改了数据，如果其他事务有更新的话，正在提交的事务会进行回滚，在数据提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突了，则返回用户错误的信息，让用户决定如何去做

实现方式：记录数据版本

## 连接

客户端的每一个连接都会在服务器进程中拥有一个线程，每个连接的查询只会在这个单独的线程中执行，该线程会轮流在某个CPU核心或者CPU中运行，服务器会负责缓存线程

##事务(ACID)

事务：是访问并可能更新各种数据项的一个执行单元，一组原子性的SQL查询，也是并发控制的基本单位，由存储引擎实现

1. 原子性(atomicity)，必须被分为一个不可分割的最小工作单元，整个事务的操作要么全部成功提交，要么失败回滚
2. 一致性(consistency)，从一个一致性的状态转换到另外一个一致性的状态
3. 隔离性(isolation)，一个事务所做的修改在最终提交前对其他事务是不可见的
4. 持久性(durability)，一旦事务提交，所做的修改就会永远保存到数据库

事务的ACID可以增加事务处理过程中的安全性，但是也会需要数据库系统做更多的额外更多，像锁粒度的升级一样会增加系统的开销，会更需要CPU处理能力，内存和磁盘空间

#### 隔离级别

Mysql定义了四种隔离级别，规定了一个事务所做的修改，哪些是事务内和事务间可见的，哪些是不可见的。。

1. read uncommitted。未提交读，事务未提交，对其他事务可见，总是读取最新的数据行
2. read commited。提交读，大多数数据库系统的默认隔离级别，一个事务开始前只能看见已经提交了的事务
3. repeatable 可重复读
4. serializable 可串性化，对所有读取的行都加锁

#### 死锁

两个或者多个事务在统一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象

数据库系统实现了死锁检测和死锁超时机制，越复杂的系统越能检测到死锁循环的依赖，并返回一个错误

innoDB处理方式：死锁时，将持有最少行级排他锁的事务进行回滚

Mysql默认自动提交模式，如果不是显示的开始一个事务，则每个查询都被当作一个事务执行提交操作，可以通过设置autocommit来启用或者禁用自动提交模式

####多版本并发控制(MVCC)

大多数的存储引擎实现的都不是简单的行级锁，为了并发性能的考虑，都实现了多版本的并发控制，即MVCC，是行级锁的一个变种，实现了非阻塞的读操作，只针对读

通过保存数据在某一个时间点的快照来实现的，不管执行多长时间，每个事务看到的数据是一致的

对于同一张表，事务开始的时间不同，可能读到的数据也不同

InnoDB通过在每行记录的后面保存两个隐藏的列来实现，其中一列保存行的创建时间，其中一个保存行的过期时间，存储的并不是实际时间值，而是系统版本号，没开始一个新的事务，系统版本号就回递增，事务开始时刻的系统版本号作为事务的版本号，用来和查询到的数据的版本号进行比较

MVCC只在可重复读和提交读两个隔离级别下工作，其他两个级别不兼容

