[TOC]

# 树

树形结构是区别于线性结构的另一大数据结构，具有分支性和层次性

概念：由n个结点构成的有限集合，n=0时为空树，否则应满足以下条件：

1. 有且仅有一个根结点
2. 其余节点分成互不相交的有限集合，每一个集合也是一棵树，称为根结点的子树

树形结构除了使用集合即`{A, B, C}`的表示方法还有括号表示法，凹入表示法和嵌套集合表示法

度：某一节点拥有的子女数称为该节点的度，树中所有节点度的最大值称为树的度

树枝：连接连个节点的线段

叶子结点或者终端结点：度为0的结点

## 定义

存储时需体现出节点的值和节点之间的相互关系

存储结构包含：

1. 双亲表示法
2. 孩子表示法
3. 孩子兄弟表示法

# 二叉树

定义：由一个根结点及两颗互不相交的分别称作这个根结点的左子树和右子树的二叉树组成

二叉树并非一般树形结构的特殊形式，区别在于：

1. 二叉树每个非空结点最多只有两个子女，而一般的树形结构中每个非空结点可以有0到多个子女
2. 二叉树结点的子树要区分左子树和右子树，即使结点只有一棵子树也要区分

性质：

1. 非空二叉树的第i层至多有$2^{i-1}$个结点
2. 深度为h的二叉树至多有$2^h-1$个结点

满二叉树：所有终端结点均位于同一层次，且其他非终端结点的度数为2，则为满二叉树

完全二叉树：二叉树扣除最大层次的那层后称为一棵满二叉树，且层次最大的那层的所有结点均向左靠齐，则为完全二叉树，完全二叉树只有最下面的两层度数可以小于2，且最下面一层结点都集中在左边

## 存储结构

### 顺序存储

使用数组存储每一个结点，结点信息需要包含该结点值，左右子树在数组中的下标，也可保存双亲的下标

缺点是：需要提前知道结点的个数，给出数组的存储空间的大小，在某些情况下，该值难以确定

### 链式存储

链式存储的方式下每个节点包含三个域，该结点的属性值及左右子树的位置，与顺序存储方式不同的是，其左右子树的位置不是通过数组的下标，而是通过指针的方式体现的

链式二叉树的定义及遍历：

```python
class NewNodeTree:

    def __init__(self, value, l_child=None, r_child=None):
        self.value = value
        self.l_child = l_child
        self.r_child = r_child


def pre_order(self):
    if not self:
        return
    print(self.value)
    pre_order(self.l_child)
    pre_order(self.r_child)


def in_order(self):
    if not self:
        return
    pre_order(self.l_child)
    print(self.value)
    pre_order(self.r_child)


def post_order(self):
    if not self:
        return

    pre_order(self.l_child)
    pre_order(self.r_child)
    print(self.value)
```

# 检索

静态查找表：检索的前后不改变查找表的内容

动态查找表：伴随着数据的增添，删除或者移动

ASL：平均查找长度，衡量检索算法效率的标准

## 线性表的检索

1. 顺序检索：逐个扫描
2. 二分法检索：基于有序数据，查找表需要按照关键字从小到大或者从大到小
3. 分块检索：是顺序检索和二分检索的结合，基本思想：将线性表分成若干块，每一块中结点的存放不一定有序，但是块与块之间是分块有序的；需要一个索引表，将每一块中最大的关键码按块的顺序存放在索引顺序表中，该索引表按照关键码值的递增次序排好序的，查找时首先在索引表中采用二分检索或者顺序检索法确定待检索对象可能所在块的起始地址，然后在所在的块内去顺序检索待查找的数据元素，便可得到检索结果

## 二叉排序树(二叉搜索树，二叉查找树，BST)

线性表的检索方法，二分检索具有最高的查找效率，但是只是拥有有序数据，这给查找表中的数据的增添，删除操作带来不便

二叉排序树又称为二叉查找树，满足以下性质：

1. 若是左子树非空，则左子树上所有结点的值均小于根结点的值
2. 若是右子树非空，则右子树上所有结点的值均大于根结点的值
3. 它的左右子树本身又是一棵二叉排序树

对二叉排序树进行中序遍历可以得到按结点值递增排序的结点序列，当只有左子树或只有右子树时，二叉排序树已经退化成单链表，具有较低的效率

二叉排序树的生成与结点的输入次序无关

### 结点的删除

1. 待删除结点为叶结点，可直接删除，若同时也是根结点，则删除后二叉排序树变为空树
2. 待删除结点只有左子树，而无右子树
3. 待删除结点只有右子树，而无左子树
4. 待删除结点即有右子树也有左子树

## 丰满树和平衡二叉排序树

为了解决平衡二叉树退化成一个具有单个分支的单链表造成的性能倒退

###丰满树

丰满树：任意两个非双孩子结点的高度之差绝对值要小于等于1

丰满树相对于二叉排序树进行插入和删除等操作后，丰满树很容易变成为非丰满二叉排序树，并且将非丰满二叉排序树改造成丰满二叉排序树非常困难，所以出现了平衡树

###平衡二叉排序树

平衡树：又称AVL树，平衡查找树，或是一棵空树，或者左子树和右子树都是平衡二叉树，且左子树和右子树高度之差的绝对值不超过1，即树中任意结点的平衡因子的绝对值小于或等于1的二叉树

有严格的平衡要求，但是维持平衡需要更多的旋转，所以很少采用

平衡因子：二叉树中的某个节点的左子树高度与右子树高度之差称为该结点的平衡因子

丰满树一定是平衡树，但是平衡树不一定是丰满树

动态的使一棵二叉排序树树保持平衡，从而使其具有较高的检索效率

## 最佳二叉排序树和Huffman树

## B树

二叉查找树的查找效率是非常高的，并且可以通过降低树的深度来提高查找的效率，但是数据量大的时候，树的存储的元素数量是有限的，这样会导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，另外数据量过大会导致内存空间不够容纳平衡二叉树所有结点的情况。

适合于较大的，存放在外存储器上的文件，B树是一种多路平衡查找树，适合在磁盘等直接存取设备上组织动态的索引表，动态索引结构在文件创建，初始装入记录时生成，在系统运行过程中插入或删除记录时，索引结构本身也可能发生改变，以保持较好的检索性能。

它能够存储数据，对其进行排序并允许以$O(log^n)$的时间复杂度运行进行查找。顺序读取。插入和删除的数据结构。概括来说是一个节点可以拥有多于2个子结点的二叉查找树，与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。该算法减少定位记录时所经历的中间过程，从而加快存取速度，普遍运用在数据库和文件系统

B。表示平衡，balance

### B-树

是一种平衡的多路查找树，在文件系统中，已经成为了索引文件的一种有效结构，比BST更宽，更矮,为了提高磁盘或者外部存储设备查找效率而产生的一种多路平衡查找树

一棵m阶(m>=3)B-树，或者为空树，或者为满足下列特性的m叉树

1. 树中的每个结点至多有m棵子树，且m>2
2. 若根结点不是叶子结点，则至少有两颗子树,最多有m棵子树
3. 除根结点以外的非叶子结点的儿子树为[m/2, m]
4. 每个节点至少存放[${\frac m2}-1$,m-1]个关键字
5. 非叶子结点的关键字个数=指向儿子的指针个数-1
6. 非叶子结点的关键字：K[1], K[2], …..K[m-1];且K[i]<K[i+1]
7. 非叶子结点的指针：P[1], p[2], …..P[m];其中P[1]指向关键字小于K[1]的子树，P[m]指向关键字大于K[m-1]的子树，其他P[i]指向关键字属于(K[i-1],K[i])的子树
8. 所有叶子结点位于同一层。

B树的搜索，从根结点开始，对结点内的关键字序列进行二分查找，如果命中则劫数，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空或者已经是叶子结点

特性：

1. 关键字集合分布在整棵树中
2. 任何一个关键字出现且只出现在一个节点中
3. 搜索有可能在非叶子结点结束
4. 其搜索性能等价于在关键字全集内做一次二分查找
5. 自动层次控制

搜索性能：$O(\log_2 n)$

性能总是等价于二分查找，也就没有B树平衡的问题，但是由于${\frac m2}$的限制，在插入结点时，如果结点已经满了，需要将结点分裂为两个各占${\frac m2}$的结点；删除结点时，需要将两个不足${\frac m2}$的兄弟结点合并

### B+树

是B-树的变体，是一种多路搜索树，定义与B-树基本相同，除了以下：

1. 非叶子结点的子树指针与关键个数相同(B-树当中指针比关键字个数少1)
2. 非叶子结点的子树脂针P[i]，指向关键字值属于[K[i], K[i+1]]的子树
3. 为所有叶子结点增加一个链指针
4. 所有关键字都在叶子结点出现

B+树的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中，因为所有的关键字被存储在叶子结点上，其性能等价于在关键字全集做一次二分查找

特性：

1. 所有关键字都出现在叶子结点的链表中(稠密索引)，且链表中的关键字恰好是有序的
2. 不可能在非叶子结点命中
3. 非叶子结点相当于叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层
4. 更适合文件索引系统，或者数据库系统
5. 通常B+树会有两个头指针，一个指向根结点，另一个指向由所有叶子结点链接成一个不定长的线性链表表头结点

## 红黑树

一种平衡的二叉查找树，时间复杂度$O(lg^n)$具有以下特性：

1. 结点是红色或者黑色
2. 根结点是黑色
3. 每个叶子的结点都是黑色的空结点
4. 每个红色结点的两个叶子结点都是黑色的
5. 从任意结点到其他每个叶子的所有路径都包含相同的黑色结点

插入操作：

插入或者删除时，会对平衡造成破坏，这时候需要对树进行调整，重新达到平衡

1. 变色
2. 旋转，左旋转或者右旋转



## 对比

| 结构   | 性质           | 优势                                                         | 劣势                                                         | 遍历                                     | 用途                                                         |
| ------ | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------- | ------------------------------------------------------------ |
| B树    | 多路平衡查找树 | 所有结点都带有指向记录的指针，且每个结点的指针个数总是比关键字个数大1，内部结点的数据可直接获得，不需要根据子结点进行定位 | 需要在叶子结点和内部结点之间不停的往返移动，因为叶子结点之间没有指针链接，所以扫描时更加困难 | 中序遍历，不支持范围搜索                 |                                                              |
| B+树   | 同上           | 1. 只有叶子结点会带有指向记录的指针，所有数据存储在叶结点上，内部结点只存放关键字和孩子指针，2.降低了树的高度，同时一个内部结点可以定位更多的叶子结点，3.遍历更加高效 |                                                              | 可以直接从叶子结点进行扫描，支持范围搜索 | 数据库索引和文件索引                                         |
| 红黑树 | 二叉平衡查找树 | 在二叉排序树的基础上解决了树的平衡问题，不会出现只插入多左子树或者右子树导致的性能低下问题 | 大规模数据存储时，会出现深度过大，而造成磁盘IO读写频繁进而导致效率低下 | 中序遍历                                 | 存储有序数据，尤其是查询时，只查询一个的时候，JAVA当中的TreeSet和TreeMap， C++STL中的set。map |



 ### 问题

为什么B+树的磁盘读写代价更低？

因为B+树的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对于B树更小，如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量越多，一次性读入内存中可以查找的关键字也就越多，相对来说IO读写次数也就降低了

B+树的查询效率更稳定？

由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以任何关键字的查找必须走一条从根结点到叶子结点的路，所有关键字查询的路径长度相同，导致每个数据查询的效率相当

数据库采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题，为了解决该问题，B+树产生了，B+树只要遍历叶子结点就可以实现整棵树的遍历，在数据库当中基于范围的查询是非常频繁的，而B树不支持这样的操作。





